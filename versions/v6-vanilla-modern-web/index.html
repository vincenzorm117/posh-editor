<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Contenteditable Bold (No execCommand)</title>
    <style>
      :root {
        --border: #d0d7de;
        --bg: #ffffff;
        --ui: #f6f8fa;
        --text: #111827;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
        color: var(--text);
        background: #fafafa;
        padding: 24px;
      }

      .wrap {
        max-width: 900px;
        margin: 0 auto;
      }

      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 10px;
        background: var(--ui);
        border: 1px solid var(--border);
        border-bottom: 0;
        border-radius: 10px 10px 0 0;
      }

      .toolbar button {
        appearance: none;
        border: 1px solid var(--border);
        background: var(--bg);
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
      }

      .toolbar button:hover {
        background: #f3f4f6;
      }

      .toolbar button[aria-pressed="true"] {
        background: #e5e7eb;
      }

      #editor {
        border: 1px solid var(--border);
        background: var(--bg);
        border-radius: 0 0 10px 10px;
        padding: 14px;
        min-height: 220px;
        outline: none;
        line-height: 1.45;
      }

      /* Just to make example content look decent */
      #editor h2 {
        margin: 0 0 10px;
      }
      #editor p {
        margin: 0 0 10px;
      }
      #editor ul {
        margin: 0 0 10px 20px;
      }
      #editor code {
        background: #f3f4f6;
        padding: 0 4px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="toolbar">
        <button id="boldBtn" type="button" aria-pressed="false" title="Bold">
          <span style="font-weight: 800">B</span>
        </button>
      </div>

      <div id="editor" contenteditable="true">
        <h2>Example HTML in the editor</h2>
        <p>
          Select some text and click <strong>Bold</strong>. This editor contains multiple blocks so you
          can verify paragraphs/headings/layout are preserved.
        </p>
        <p>
          You can also select across <em>inline</em> content, lists, and even parts of different
          paragraphs.
        </p>
        <ul>
          <li>List item one</li>
          <li>List item two with <code>inline code</code></li>
        </ul>
        <p>Try bolding a selection that spans multiple lines.</p>
      </div>
    </div>

    <script>
      const editor = document.getElementById("editor");
      const boldBtn = document.getElementById("boldBtn");

      function selectionIsInEditor(sel) {
        if (!sel || sel.rangeCount === 0) return false;
        const range = sel.getRangeAt(0);
        // commonAncestorContainer can be a Text node; use parentElement to check containment safely.
        const node =
          range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE
            ? range.commonAncestorContainer
            : range.commonAncestorContainer.parentElement;
        return node ? editor.contains(node) || node === editor : false;
      }

      function toggleInlineTagInRange(range, tagName) {
        // We want to preserve block layout: only wrap/unwrap inline content.
        // 1) If selection is collapsed: insert an empty <strong> and place caret inside.
        if (range.collapsed) {
          const el = document.createElement(tagName);
          el.appendChild(document.createTextNode("\u200B")); // zero-width space to keep caret inside
          range.insertNode(el);

          // Move caret inside the new element (after the ZWSP)
          const sel = window.getSelection();
          sel.removeAllRanges();
          const r = document.createRange();
          r.setStart(el.firstChild, 1);
          r.setEnd(el.firstChild, 1);
          sel.addRange(r);
          return;
        }

        // 2) If selection is NOT collapsed:
        // Extract contents, wrap them in <strong>, re-insert.
        // This preserves existing block nodes (p, h2, li, etc.) because we don't replace them;
        // we wrap only the extracted fragment.
        const fragment = range.extractContents();

        // If the extracted fragment is already fully wrapped in <strong>, unwrap it.
        // This is a conservative check: single top-level STRONG and nothing else.
        if (
          fragment.childNodes.length === 1 &&
          fragment.firstChild.nodeType === Node.ELEMENT_NODE &&
          fragment.firstChild.tagName === tagName.toUpperCase()
        ) {
          const strongEl = fragment.firstChild;
          const unwrapped = document.createDocumentFragment();
          while (strongEl.firstChild) unwrapped.appendChild(strongEl.firstChild);
          range.insertNode(unwrapped);
        } else {
          const wrapper = document.createElement(tagName);
          wrapper.appendChild(fragment);
          range.insertNode(wrapper);
        }

        // Restore selection around the inserted content
        const sel = window.getSelection();
        sel.removeAllRanges();
        const newRange = document.createRange();

        // Select the node we inserted (best effort)
        const insertedNode = range.startContainer.childNodes[range.startOffset]
          ? range.startContainer.childNodes[range.startOffset]
          : range.startContainer;

        try {
          newRange.selectNodeContents(insertedNode);
        } catch {
          // Fallback: just place caret at end of editor
          newRange.selectNodeContents(editor);
          newRange.collapse(false);
        }
        sel.addRange(newRange);
      }

      function updateBoldButtonState() {
        const sel = window.getSelection();
        const inEditor = selectionIsInEditor(sel);
        if (!inEditor || !sel || sel.rangeCount === 0) {
          boldBtn.setAttribute("aria-pressed", "false");
          return;
        }

        // Heuristic: if caret/selection start is inside <strong> or <b>, show pressed
        const range = sel.getRangeAt(0);
        const node =
          range.startContainer.nodeType === Node.ELEMENT_NODE
            ? range.startContainer
            : range.startContainer.parentElement;

        const isBold = node && node.closest && (node.closest("strong") || node.closest("b"));
        boldBtn.setAttribute("aria-pressed", isBold ? "true" : "false");
      }

      boldBtn.addEventListener("mousedown", (e) => {
        // Prevent losing selection when clicking button
        e.preventDefault();
      });

      boldBtn.addEventListener("click", () => {
        const sel = window.getSelection();
        if (!selectionIsInEditor(sel) || !sel || sel.rangeCount === 0) return;

        const range = sel.getRangeAt(0);

        // Use <strong> for semantic bold
        toggleInlineTagInRange(range, "strong");
        editor.focus();
        updateBoldButtonState();
      });

      document.addEventListener("selectionchange", () => {
        updateBoldButtonState();
      });

      editor.addEventListener("input", () => {
        // Optional: clean up any stray zero-width spaces left behind
        // (keeps caret-insert bold usable without accumulating ZWSPs)
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT);
        const toFix = [];
        while (walker.nextNode()) {
          if (walker.currentNode.nodeValue.includes("\u200B")) toFix.push(walker.currentNode);
        }
        for (const n of toFix) {
          n.nodeValue = n.nodeValue.replaceAll("\u200B", "");
        }
      });
    </script>
  </body>
</html>