<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Rich Text Editor - v7</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding: 40px;
            background: #f5f5f5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .toolbar {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
        }

        .toolbar button {
            padding: 8px 16px;
            border: 1px solid #d0d0d0;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .toolbar button:hover {
            background: #f0f0f0;
            border-color: #b0b0b0;
        }

        .toolbar button:active {
            background: #e0e0e0;
        }

        .toolbar button.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        #editor {
            min-height: 400px;
            padding: 24px;
            outline: none;
            font-size: 16px;
            line-height: 1.6;
        }

        #editor h1 {
            font-size: 2em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        #editor h2 {
            font-size: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        #editor h3 {
            font-size: 1.25em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        #editor p {
            margin-bottom: 1em;
        }

        #editor ul, #editor ol {
            margin-left: 2em;
            margin-bottom: 1em;
        }

        #editor li {
            margin-bottom: 0.5em;
        }

        #editor strong {
            font-weight: 600;
        }

        #editor:focus {
            background: #fafafa;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <button id="boldBtn" title="Bold (Ctrl+B)">Bold</button>
        </div>
        <div id="editor" contenteditable="true">
            <h1>Welcome to the Modern Rich Text Editor</h1>
            <p>This is a paragraph with some <strong>bold text</strong> already in it. Select any text and click the Bold button to toggle bold formatting.</p>
            <h2>Features</h2>
            <p>This editor maintains the structure of your document including:</p>
            <ul>
                <li>Paragraphs and their formatting</li>
                <li>Headlines at different levels</li>
                <li>Lists and their items</li>
                <li>Line breaks and spacing</li>
            </ul>
            <h3>Try It Out</h3>
            <p>Select text across multiple elements and apply bold formatting. The structure will be preserved!</p>
            <p>You can select text within a single paragraph, or across multiple paragraphs and headlines.</p>
        </div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const boldBtn = document.getElementById('boldBtn');

        // Update button state based on current selection
        function updateToolbarState() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            const range = selection.getRangeAt(0);
            if (!editor.contains(range.commonAncestorContainer)) return;

            // Check if the entire selection is bold
            const isBold = isSelectionBold(range);
            boldBtn.classList.toggle('active', isBold);
        }

        // Check if selection is bold
        function isSelectionBold(range) {
            const container = range.commonAncestorContainer;
            
            // If selection is collapsed, check parent chain
            if (range.collapsed) {
                let node = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
                while (node && node !== editor) {
                    if (node.tagName === 'STRONG' || node.tagName === 'B') {
                        return true;
                    }
                    node = node.parentElement;
                }
                return false;
            }

            // For non-collapsed selections, check if all text nodes are bold
            const walker = document.createTreeWalker(
                range.commonAncestorContainer,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: (node) => {
                        if (range.intersectsNode(node) && node.textContent.trim()) {
                            return NodeFilter.FILTER_ACCEPT;
                        }
                        return NodeFilter.FILTER_REJECT;
                    }
                }
            );

            let node;
            let hasBoldText = false;
            let hasNonBoldText = false;

            while (node = walker.nextNode()) {
                let parent = node.parentElement;
                let isBold = false;
                while (parent && parent !== editor) {
                    if (parent.tagName === 'STRONG' || parent.tagName === 'B') {
                        isBold = true;
                        break;
                    }
                    parent = parent.parentElement;
                }
                
                if (isBold) {
                    hasBoldText = true;
                } else {
                    hasNonBoldText = true;
                }
            }

            return hasBoldText && !hasNonBoldText;
        }

        // Toggle bold on selection
        function toggleBold() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            const range = selection.getRangeAt(0);
            if (!editor.contains(range.commonAncestorContainer)) return;

            // Save selection
            const savedRange = range.cloneRange();

            // Check if we should bold or unbold
            const shouldBold = !isSelectionBold(range);

            if (shouldBold) {
                applyBold(range);
            } else {
                removeBold(range);
            }

            // Restore selection
            try {
                selection.removeAllRanges();
                selection.addRange(savedRange);
            } catch (e) {
                // Selection might be invalid after DOM changes
            }

            updateToolbarState();
        }

        // Apply bold to range
        function applyBold(range) {
            // Get all text nodes in the range
            const textNodes = getTextNodesInRange(range);

            textNodes.forEach(({ node, startOffset, endOffset }) => {
                // Check if already in a bold element
                let parent = node.parentElement;
                let isAlreadyBold = false;
                while (parent && parent !== editor) {
                    if (parent.tagName === 'STRONG' || parent.tagName === 'B') {
                        isAlreadyBold = true;
                        break;
                    }
                    parent = parent.parentElement;
                }

                if (isAlreadyBold) return;

                // Split the text node if necessary
                if (endOffset < node.textContent.length) {
                    node.splitText(endOffset);
                }
                
                let nodeToWrap = node;
                if (startOffset > 0) {
                    nodeToWrap = node.splitText(startOffset);
                }

                // Wrap in strong tag
                const strong = document.createElement('strong');
                nodeToWrap.parentNode.insertBefore(strong, nodeToWrap);
                strong.appendChild(nodeToWrap);
            });

            // Merge adjacent strong elements
            mergeAdjacentElements(editor, 'STRONG');
        }

        // Remove bold from range
        function removeBold(range) {
            const textNodes = getTextNodesInRange(range);

            textNodes.forEach(({ node, startOffset, endOffset }) => {
                // Find bold ancestor
                let boldElement = null;
                let parent = node.parentElement;
                
                while (parent && parent !== editor) {
                    if (parent.tagName === 'STRONG' || parent.tagName === 'B') {
                        boldElement = parent;
                        break;
                    }
                    parent = parent.parentElement;
                }

                if (!boldElement) return;

                // Split the text node if necessary
                if (endOffset < node.textContent.length) {
                    node.splitText(endOffset);
                }
                
                let nodeToUnwrap = node;
                if (startOffset > 0) {
                    nodeToUnwrap = node.splitText(startOffset);
                }

                // If the entire bold element content is selected, unwrap it
                if (boldElement.childNodes.length === 1 && boldElement.childNodes[0] === nodeToUnwrap) {
                    unwrapElement(boldElement);
                } else {
                    // Partial selection, need to split the bold element
                    const before = [];
                    const after = [];
                    let foundNode = false;
                    let current = boldElement.firstChild;

                    while (current) {
                        const next = current.nextSibling;
                        if (current === nodeToUnwrap) {
                            foundNode = true;
                            boldElement.removeChild(current);
                            boldElement.parentNode.insertBefore(current, boldElement.nextSibling);
                        } else if (!foundNode) {
                            before.push(current);
                        } else {
                            after.push(current);
                        }
                        current = next;
                    }

                    // If bold element is now empty, remove it
                    if (boldElement.childNodes.length === 0) {
                        boldElement.remove();
                    }

                    // If there are nodes after, create a new bold element for them
                    if (after.length > 0 && boldElement.parentNode) {
                        const newBold = document.createElement('strong');
                        after.forEach(node => newBold.appendChild(node));
                        boldElement.parentNode.insertBefore(newBold, nodeToUnwrap.nextSibling);
                    }
                }
            });
        }

        // Get all text nodes in range with their offsets
        function getTextNodesInRange(range) {
            const textNodes = [];
            const walker = document.createTreeWalker(
                range.commonAncestorContainer,
                NodeFilter.SHOW_TEXT,
                null
            );

            let node;
            while (node = walker.nextNode()) {
                if (!range.intersectsNode(node)) continue;
                if (!node.textContent.trim() && node.textContent.length === 0) continue;

                let startOffset = 0;
                let endOffset = node.textContent.length;

                // Adjust offsets for start and end nodes
                if (node === range.startContainer) {
                    startOffset = range.startOffset;
                }
                if (node === range.endContainer) {
                    endOffset = range.endOffset;
                }

                if (startOffset < endOffset) {
                    textNodes.push({ node, startOffset, endOffset });
                }
            }

            return textNodes;
        }

        // Unwrap an element (replace it with its children)
        function unwrapElement(element) {
            const parent = element.parentNode;
            while (element.firstChild) {
                parent.insertBefore(element.firstChild, element);
            }
            parent.removeChild(element);
        }

        // Merge adjacent elements of the same type
        function mergeAdjacentElements(container, tagName) {
            const elements = container.querySelectorAll(tagName);
            elements.forEach(element => {
                let next = element.nextSibling;
                while (next) {
                    if (next.nodeType === Node.ELEMENT_NODE && next.tagName === tagName) {
                        while (next.firstChild) {
                            element.appendChild(next.firstChild);
                        }
                        const toRemove = next;
                        next = next.nextSibling;
                        toRemove.remove();
                    } else if (next.nodeType === Node.TEXT_NODE && !next.textContent.trim()) {
                        // Skip empty text nodes
                        next = next.nextSibling;
                    } else {
                        break;
                    }
                }
            });
        }

        // Event listeners
        boldBtn.addEventListener('click', (e) => {
            e.preventDefault();
            toggleBold();
            editor.focus();
        });

        // Update toolbar state on selection change
        document.addEventListener('selectionchange', () => {
            updateToolbarState();
        });

        // Keyboard shortcut
        editor.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                e.preventDefault();
                toggleBold();
            }
        });

        // Initial toolbar state
        updateToolbarState();
    </script>
</body>
</html>
