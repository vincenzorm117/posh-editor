<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual DOM Rich Text Editor</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }

    h1 {
      color: #333;
      margin-bottom: 20px;
    }

    .editor-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .toolbar {
      display: flex;
      gap: 4px;
      padding: 8px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
    }

    .toolbar button {
      padding: 8px 16px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.2s;
    }

    .toolbar button:hover {
      background: #e9ecef;
    }

    .toolbar button.active {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }

    .editor {
      min-height: 300px;
      padding: 16px;
      outline: none;
      font-size: 16px;
      line-height: 1.6;
    }

    .editor:focus {
      background: #fafafa;
    }

    .debug-panel {
      margin-top: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .debug-panel h3 {
      margin: 0;
      padding: 12px 16px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      font-size: 14px;
    }

    .debug-content {
      padding: 16px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
      background: #1e1e1e;
      color: #d4d4d4;
    }

    .selection-info {
      padding: 8px 16px;
      background: #e7f3ff;
      border-bottom: 1px solid #e0e0e0;
      font-size: 13px;
      color: #0066cc;
    }
  </style>
</head>
<body>
  <h1>Virtual DOM Rich Text Editor</h1>
  
  <div class="editor-container">
    <div class="toolbar">
      <button id="boldBtn" title="Bold (Ctrl+B)"><strong>B</strong></button>
    </div>
    <div class="editor" id="editor" contenteditable="true"></div>
  </div>

  <div class="debug-panel">
    <h3>Virtual DOM State</h3>
    <div class="selection-info" id="selectionInfo">Selection: None</div>
    <div class="debug-content" id="debugContent"></div>
  </div>

  <script>
    // ============================================
    // VIRTUAL DOM IMPLEMENTATION
    // ============================================

    /**
     * Creates a virtual DOM node
     * @param {string} type - Element type (e.g., 'div', 'span', 'text')
     * @param {Object} props - Properties/attributes
     * @param {Array} children - Child nodes
     * @returns {Object} Virtual node
     */
    function createVNode(type, props = {}, children = []) {
      return {
        type,
        props,
        children: Array.isArray(children) ? children : [children],
      };
    }

    /**
     * Creates a text virtual node
     * @param {string} text - Text content
     * @returns {Object} Virtual text node
     */
    function createTextVNode(text) {
      return {
        type: 'TEXT',
        text: text,
        props: {},
        children: [],
      };
    }

    /**
     * Renders a virtual node to a real DOM element
     * @param {Object} vnode - Virtual node
     * @returns {Node} Real DOM node
     */
    function renderVNode(vnode) {
      if (vnode.type === 'TEXT') {
        return document.createTextNode(vnode.text);
      }

      const element = document.createElement(vnode.type);

      // Apply props
      for (const [key, value] of Object.entries(vnode.props)) {
        if (key.startsWith('on') && typeof value === 'function') {
          element.addEventListener(key.slice(2).toLowerCase(), value);
        } else if (key === 'className') {
          element.className = value;
        } else {
          element.setAttribute(key, value);
        }
      }

      // Render children
      for (const child of vnode.children) {
        element.appendChild(renderVNode(child));
      }

      return element;
    }

    /**
     * Diffs two virtual nodes and returns patches
     * @param {Object} oldVNode - Old virtual node
     * @param {Object} newVNode - New virtual node
     * @returns {Object} Patch object
     */
    function diff(oldVNode, newVNode) {
      // If new node doesn't exist, remove old
      if (!newVNode) {
        return { type: 'REMOVE' };
      }

      // If old node doesn't exist, add new
      if (!oldVNode) {
        return { type: 'CREATE', newVNode };
      }

      // If types differ, replace
      if (oldVNode.type !== newVNode.type) {
        return { type: 'REPLACE', newVNode };
      }

      // If text nodes, check text content
      if (oldVNode.type === 'TEXT') {
        if (oldVNode.text !== newVNode.text) {
          return { type: 'TEXT', text: newVNode.text };
        }
        return null;
      }

      // Diff props
      const propPatches = diffProps(oldVNode.props, newVNode.props);

      // Diff children
      const childPatches = diffChildren(oldVNode.children, newVNode.children);

      if (propPatches.length === 0 && childPatches.length === 0) {
        return null;
      }

      return { type: 'UPDATE', propPatches, childPatches };
    }

    function diffProps(oldProps, newProps) {
      const patches = [];

      // Check for changed/added props
      for (const [key, value] of Object.entries(newProps)) {
        if (oldProps[key] !== value) {
          patches.push({ type: 'SET', key, value });
        }
      }

      // Check for removed props
      for (const key of Object.keys(oldProps)) {
        if (!(key in newProps)) {
          patches.push({ type: 'REMOVE', key });
        }
      }

      return patches;
    }

    function diffChildren(oldChildren, newChildren) {
      const patches = [];
      const maxLength = Math.max(oldChildren.length, newChildren.length);

      for (let i = 0; i < maxLength; i++) {
        patches.push(diff(oldChildren[i], newChildren[i]));
      }

      return patches;
    }

    /**
     * Applies patches to the real DOM
     * @param {Node} parent - Parent DOM node
     * @param {Object} patch - Patch to apply
     * @param {number} index - Child index
     */
    function applyPatch(parent, patch, index = 0) {
      if (!patch) return;

      const element = parent.childNodes[index];

      switch (patch.type) {
        case 'CREATE':
          parent.appendChild(renderVNode(patch.newVNode));
          break;

        case 'REMOVE':
          if (element) parent.removeChild(element);
          break;

        case 'REPLACE':
          if (element) {
            parent.replaceChild(renderVNode(patch.newVNode), element);
          } else {
            parent.appendChild(renderVNode(patch.newVNode));
          }
          break;

        case 'TEXT':
          if (element) element.textContent = patch.text;
          break;

        case 'UPDATE':
          if (element) {
            // Apply prop patches
            for (const propPatch of patch.propPatches) {
              if (propPatch.type === 'SET') {
                if (propPatch.key === 'className') {
                  element.className = propPatch.value;
                } else {
                  element.setAttribute(propPatch.key, propPatch.value);
                }
              } else if (propPatch.type === 'REMOVE') {
                element.removeAttribute(propPatch.key);
              }
            }

            // Apply child patches
            for (let i = 0; i < patch.childPatches.length; i++) {
              applyPatch(element, patch.childPatches[i], i);
            }
          }
          break;
      }
    }

    // ============================================
    // VIRTUAL SELECTION IMPLEMENTATION
    // ============================================

    /**
     * Virtual Selection - tracks selection in terms of virtual DOM
     */
    class VirtualSelection {
      constructor() {
        this.anchorPath = [];
        this.anchorOffset = 0;
        this.focusPath = [];
        this.focusOffset = 0;
        this.isCollapsed = true;
      }

      /**
       * Updates the virtual selection from a path-based selection
       */
      set(anchorPath, anchorOffset, focusPath, focusOffset) {
        this.anchorPath = [...anchorPath];
        this.anchorOffset = anchorOffset;
        this.focusPath = [...focusPath];
        this.focusOffset = focusOffset;
        this.isCollapsed = 
          this.anchorPath.join(',') === this.focusPath.join(',') && 
          this.anchorOffset === this.focusOffset;
      }

      /**
       * Gets normalized selection (start before end)
       */
      getNormalized() {
        const comparison = this.comparePaths(this.anchorPath, this.anchorOffset, this.focusPath, this.focusOffset);
        if (comparison <= 0) {
          return {
            startPath: this.anchorPath,
            startOffset: this.anchorOffset,
            endPath: this.focusPath,
            endOffset: this.focusOffset,
          };
        } else {
          return {
            startPath: this.focusPath,
            startOffset: this.focusOffset,
            endPath: this.anchorPath,
            endOffset: this.anchorOffset,
          };
        }
      }

      /**
       * Compares two positions
       * Returns -1 if pos1 < pos2, 0 if equal, 1 if pos1 > pos2
       */
      comparePaths(path1, offset1, path2, offset2) {
        const minLen = Math.min(path1.length, path2.length);
        for (let i = 0; i < minLen; i++) {
          if (path1[i] < path2[i]) return -1;
          if (path1[i] > path2[i]) return 1;
        }
        if (path1.length < path2.length) return -1;
        if (path1.length > path2.length) return 1;
        return offset1 - offset2;
      }

      clone() {
        const sel = new VirtualSelection();
        sel.anchorPath = [...this.anchorPath];
        sel.anchorOffset = this.anchorOffset;
        sel.focusPath = [...this.focusPath];
        sel.focusOffset = this.focusOffset;
        sel.isCollapsed = this.isCollapsed;
        return sel;
      }

      toJSON() {
        return {
          anchorPath: this.anchorPath,
          anchorOffset: this.anchorOffset,
          focusPath: this.focusPath,
          focusOffset: this.focusOffset,
          isCollapsed: this.isCollapsed,
        };
      }
    }

    // ============================================
    // RICH TEXT EDITOR
    // ============================================

    class VirtualRichTextEditor {
      constructor(containerElement) {
        this.container = containerElement;
        this.vdom = this.createInitialVDOM();
        this.selection = new VirtualSelection();
        this.boldButton = document.getElementById('boldBtn');
        
        this.init();
      }

      createInitialVDOM() {
        // Initial content: a single paragraph with text
        return createVNode('div', { className: 'content' }, [
          createVNode('p', {}, [
            createTextVNode('Welcome to the Virtual DOM Rich Text Editor. Select some text and click Bold to toggle formatting.')
          ])
        ]);
      }

      init() {
        // Initial render
        this.render();

        // Set up event listeners
        this.container.addEventListener('input', this.handleInput.bind(this));
        this.container.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('selectionchange', this.handleSelectionChange.bind(this));
        this.boldButton.addEventListener('click', this.toggleBold.bind(this));

        this.updateDebug();
      }

      /**
       * Renders the virtual DOM to the real DOM
       */
      render() {
        // Clear and re-render
        this.container.innerHTML = '';
        for (const child of this.vdom.children) {
          this.container.appendChild(renderVNode(child));
        }

        this.updateDebug();
      }

      /**
       * Renders and restores a specific selection
       */
      renderWithSelection(selectionInfo) {
        // Clear and re-render
        this.container.innerHTML = '';
        for (const child of this.vdom.children) {
          this.container.appendChild(renderVNode(child));
        }

        // Restore selection if provided
        if (selectionInfo) {
          this.restoreSelectionFromInfo(selectionInfo);
        }

        this.updateDebug();
      }

      /**
       * Restores selection from selection info object
       */
      restoreSelectionFromInfo(selectionInfo) {
        const startNode = this.getNodeFromPath(selectionInfo.startPath);
        const endNode = this.getNodeFromPath(selectionInfo.endPath);

        if (!startNode || !endNode) return;

        try {
          const sel = window.getSelection();
          sel.removeAllRanges();
          
          const range = document.createRange();
          const startOffset = Math.min(selectionInfo.startOffset, startNode.textContent?.length || 0);
          const endOffset = Math.min(selectionInfo.endOffset, endNode.textContent?.length || 0);
          
          range.setStart(startNode, startOffset);
          range.setEnd(endNode, endOffset);
          sel.addRange(range);

          // Update our virtual selection
          this.selection.set(
            selectionInfo.startPath, 
            startOffset, 
            selectionInfo.endPath, 
            endOffset
          );
        } catch (e) {
          console.warn('Failed to restore selection:', e);
        }
      }

      /**
       * Saves the current DOM selection as virtual selection
       */
      saveSelection() {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return null;

        const range = sel.getRangeAt(0);
        
        const anchorPath = this.getPathToNode(range.startContainer);
        const focusPath = this.getPathToNode(range.endContainer);

        if (!anchorPath || !focusPath) return null;

        return {
          anchorPath,
          anchorOffset: range.startOffset,
          focusPath,
          focusOffset: range.endOffset,
        };
      }

      /**
       * Gets the path (array of indices) from editor root to a node
       */
      getPathToNode(node) {
        const path = [];
        let current = node;

        while (current && current !== this.container) {
          const parent = current.parentNode;
          if (!parent) return null;

          const index = Array.from(parent.childNodes).indexOf(current);
          if (index === -1) return null;

          path.unshift(index);
          current = parent;
        }

        if (current !== this.container) return null;
        return path;
      }

      /**
       * Gets a DOM node from a path
       */
      getNodeFromPath(path) {
        let node = this.container;
        for (const index of path) {
          if (!node.childNodes[index]) return null;
          node = node.childNodes[index];
        }
        return node;
      }

      /**
       * Gets a virtual node from a path
       */
      getVNodeFromPath(path) {
        let vnode = this.vdom;
        for (const index of path) {
          if (!vnode.children || !vnode.children[index]) return null;
          vnode = vnode.children[index];
        }
        return vnode;
      }

      /**
       * Restores selection from saved state
       */
      restoreSelection(savedSelection) {
        const anchorNode = this.getNodeFromPath(savedSelection.anchorPath);
        const focusNode = this.getNodeFromPath(savedSelection.focusPath);

        if (!anchorNode || !focusNode) return;

        try {
          const sel = window.getSelection();
          sel.removeAllRanges();
          
          const range = document.createRange();
          range.setStart(anchorNode, Math.min(savedSelection.anchorOffset, anchorNode.textContent?.length || 0));
          range.setEnd(focusNode, Math.min(savedSelection.focusOffset, focusNode.textContent?.length || 0));
          sel.addRange(range);
        } catch (e) {
          console.warn('Failed to restore selection:', e);
        }
      }

      /**
       * Handles selection changes
       */
      handleSelectionChange() {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return;

        // Check if selection is within our editor
        if (!this.container.contains(sel.anchorNode)) return;

        const anchorPath = this.getPathToNode(sel.anchorNode);
        const focusPath = this.getPathToNode(sel.focusNode);

        if (anchorPath && focusPath) {
          this.selection.set(anchorPath, sel.anchorOffset, focusPath, sel.focusOffset);
          this.updateBoldButtonState();
          this.updateDebug();
        }
      }

      /**
       * Handles input events - syncs DOM changes back to Virtual DOM
       */
      handleInput(event) {
        // Rebuild VDOM from current DOM state
        this.vdom = this.domToVDOM(this.container);
        this.updateDebug();
      }

      /**
       * Converts real DOM to Virtual DOM
       */
      domToVDOM(element) {
        if (element.nodeType === Node.TEXT_NODE) {
          return createTextVNode(element.textContent);
        }

        const children = [];
        for (const child of element.childNodes) {
          children.push(this.domToVDOM(child));
        }

        const props = {};
        if (element.className) {
          props.className = element.className;
        }

        // Get tag name, default to 'div' for the container
        const type = element === this.container ? 'div' : element.tagName.toLowerCase();

        return createVNode(type, props, children);
      }

      /**
       * Handles keyboard shortcuts
       */
      handleKeyDown(event) {
        if ((event.ctrlKey || event.metaKey) && event.key === 'b') {
          event.preventDefault();
          this.toggleBold();
        }
      }

      /**
       * Checks if current selection has bold formatting
       */
      isSelectionBold() {
        const { startPath, startOffset, endPath, endOffset } = this.selection.getNormalized();
        
        // Check if any part of the selection is within a bold (strong) element
        const textNodes = this.getSelectedTextNodes();
        
        if (textNodes.length === 0) return false;

        // Check if all selected text is bold
        return textNodes.every(({ path }) => {
          return this.isPathWithinBold(path);
        });
      }

      /**
       * Checks if a path leads to a node within a bold element
       */
      isPathWithinBold(path) {
        let vnode = this.vdom;
        for (let i = 0; i < path.length - 1; i++) {
          vnode = vnode.children[path[i]];
          if (!vnode) return false;
          if (vnode.type === 'strong' || vnode.type === 'b') {
            return true;
          }
        }
        return false;
      }

      /**
       * Gets all text nodes within the current selection
       */
      getSelectedTextNodes() {
        const result = [];
        const { startPath, startOffset, endPath, endOffset } = this.selection.getNormalized();
        
        this.walkVDOM(this.vdom, [], (vnode, path) => {
          if (vnode.type === 'TEXT') {
            if (this.isPathInRange(path, startPath, endPath)) {
              result.push({ vnode, path: [...path] });
            }
          }
        });

        return result;
      }

      /**
       * Walks the virtual DOM tree
       */
      walkVDOM(vnode, path, callback) {
        callback(vnode, path);
        if (vnode.children) {
          vnode.children.forEach((child, index) => {
            this.walkVDOM(child, [...path, index], callback);
          });
        }
      }

      /**
       * Checks if a path falls within a range
       */
      isPathInRange(path, startPath, endPath) {
        const cmpStart = this.selection.comparePaths(path, 0, startPath, 0);
        const cmpEnd = this.selection.comparePaths(path, 0, endPath, 0);
        return cmpStart >= 0 && cmpEnd <= 0;
      }

      /**
       * Toggles bold on the current selection
       */
      toggleBold() {
        if (this.selection.isCollapsed) return;

        const wasBold = this.isSelectionBold();
        const { startPath, startOffset, endPath, endOffset } = this.selection.getNormalized();

        // Clone the VDOM for modification
        const newVDOM = this.cloneVNode(this.vdom);

        // Track what the new selection should be after modification
        let newSelection = null;

        if (wasBold) {
          newSelection = this.removeBoldFromSelection(newVDOM, startPath, startOffset, endPath, endOffset);
        } else {
          newSelection = this.applyBoldToSelection(newVDOM, startPath, startOffset, endPath, endOffset);
        }

        // Normalize the VDOM (merge adjacent text nodes, remove empty nodes)
        this.normalizeVDOM(newVDOM);

        // Update VDOM and re-render
        this.vdom = newVDOM;
        this.renderWithSelection(newSelection);
      }

      /**
       * Deep clones a virtual node
       */
      cloneVNode(vnode) {
        if (vnode.type === 'TEXT') {
          return createTextVNode(vnode.text);
        }
        return createVNode(
          vnode.type,
          { ...vnode.props },
          vnode.children.map(child => this.cloneVNode(child))
        );
      }

      /**
       * Applies bold formatting to the selection
       * Returns new selection info after the transformation
       */
      applyBoldToSelection(vdom, startPath, startOffset, endPath, endOffset) {
        // Find all text nodes in range and wrap them in <strong>
        const modifications = [];

        this.walkVDOM(vdom, [], (vnode, path) => {
          if (vnode.type === 'TEXT') {
            const inRange = this.isTextNodeInRange(path, startPath, startOffset, endPath, endOffset);
            if (inRange.inRange) {
              modifications.push({
                path: [...path],
                startOffset: inRange.startOffset,
                endOffset: inRange.endOffset,
                fullText: vnode.text
              });
            }
          }
        });

        // Track the new selection paths
        let newStartPath = null;
        let newStartOffset = 0;
        let newEndPath = null;
        let newEndOffset = 0;

        // Apply modifications in reverse order to maintain path validity
        modifications.reverse().forEach((mod, reverseIndex) => {
          const result = this.wrapTextInBold(vdom, mod.path, mod.startOffset, mod.endOffset, mod.fullText);
          
          // The first modification (in reverse = last in document order) sets the end
          // The last modification (in reverse = first in document order) sets the start
          if (reverseIndex === 0) {
            // This is the last text node in selection (end of selection)
            if (result) {
              newEndPath = result.boldTextPath;
              newEndOffset = result.textLength;
            }
          }
          if (reverseIndex === modifications.length - 1) {
            // This is the first text node in selection (start of selection)
            if (result) {
              newStartPath = result.boldTextPath;
              newStartOffset = 0;
            }
          }
        });

        // Handle single text node selection
        if (modifications.length === 1 && newStartPath && newEndPath) {
          // Same node, just use the offsets correctly
          newStartOffset = 0;
          newEndOffset = modifications[0].endOffset - modifications[0].startOffset;
        }

        return {
          startPath: newStartPath || startPath,
          startOffset: newStartOffset,
          endPath: newEndPath || endPath,
          endOffset: newEndOffset
        };
      }

      /**
       * Checks if a text node is in the selection range and returns the offsets
       */
      isTextNodeInRange(path, startPath, startOffset, endPath, endOffset) {
        const pathStr = path.join(',');
        const startPathStr = startPath.join(',');
        const endPathStr = endPath.join(',');

        // Check if this text node is the start, end, or in between
        const isSameAsStart = pathStr === startPathStr;
        const isSameAsEnd = pathStr === endPathStr;
        
        const cmpStart = this.selection.comparePaths(path, 0, startPath, 0);
        const cmpEnd = this.selection.comparePaths(path, 0, endPath, 0);

        if (cmpStart < 0 || cmpEnd > 0) {
          return { inRange: false };
        }

        // Get the vnode to know text length
        const vnode = this.getVNodeFromPath(path);
        if (!vnode || vnode.type !== 'TEXT') {
          return { inRange: false };
        }

        const textLen = vnode.text.length;
        let resultStart = 0;
        let resultEnd = textLen;

        if (isSameAsStart) {
          resultStart = startOffset;
        }
        if (isSameAsEnd) {
          resultEnd = endOffset;
        }

        if (resultStart >= resultEnd) {
          return { inRange: false };
        }

        return {
          inRange: true,
          startOffset: resultStart,
          endOffset: resultEnd
        };
      }

      /**
       * Wraps a portion of text in a bold element
       * Returns info about the new bold text node path
       */
      wrapTextInBold(vdom, path, startOffset, endOffset, fullText) {
        // Navigate to parent of the text node
        const parentPath = path.slice(0, -1);
        const textIndex = path[path.length - 1];
        
        let parent = vdom;
        for (const idx of parentPath) {
          parent = parent.children[idx];
        }

        if (!parent || !parent.children[textIndex]) return null;

        const textNode = parent.children[textIndex];
        if (textNode.type !== 'TEXT') return null;

        const text = textNode.text;
        const beforeText = text.slice(0, startOffset);
        const selectedText = text.slice(startOffset, endOffset);
        const afterText = text.slice(endOffset);

        // Create new nodes
        const newNodes = [];
        let boldTextPath = null;
        
        if (beforeText) {
          newNodes.push(createTextVNode(beforeText));
        }
        
        // Check if parent is already bold
        if (parent.type === 'strong' || parent.type === 'b') {
          newNodes.push(createTextVNode(selectedText));
          // Path to the bold text is within the parent, at the current position
          const boldIndex = textIndex + (beforeText ? 1 : 0);
          boldTextPath = [...parentPath, boldIndex];
        } else {
          newNodes.push(createVNode('strong', {}, [createTextVNode(selectedText)]));
          // Path to the text inside the strong element
          const strongIndex = textIndex + (beforeText ? 1 : 0);
          boldTextPath = [...parentPath, strongIndex, 0];
        }
        
        if (afterText) {
          newNodes.push(createTextVNode(afterText));
        }

        // Replace the text node with new nodes
        parent.children.splice(textIndex, 1, ...newNodes);

        return {
          boldTextPath,
          textLength: selectedText.length
        };
      }

      /**
       * Removes bold formatting from the selection
       * Returns new selection info after the transformation
       */
      removeBoldFromSelection(vdom, startPath, startOffset, endPath, endOffset) {
        // Find all bold elements that contain selected text and unwrap them
        const boldNodes = [];

        this.walkVDOM(vdom, [], (vnode, path) => {
          if ((vnode.type === 'strong' || vnode.type === 'b') && vnode.children.length > 0) {
            // Check if any text within is selected
            let hasSelectedText = false;
            this.walkVDOM(vnode, path, (child, childPath) => {
              if (child.type === 'TEXT') {
                const inRange = this.isTextNodeInRange(childPath, startPath, startOffset, endPath, endOffset);
                if (inRange.inRange) {
                  hasSelectedText = true;
                }
              }
            });
            if (hasSelectedText) {
              boldNodes.push({ path: [...path], vnode });
            }
          }
        });

        // Calculate what the new selection will be after unwrapping
        // When we unwrap a <strong> at path [0, 1], its children move up to [0, 1], [0, 2], etc.
        let newStartPath = [...startPath];
        let newEndPath = [...endPath];

        // Unwrap bold nodes (in reverse order)
        boldNodes.reverse().forEach(({ path, vnode }) => {
          // Update selection paths if they reference nodes inside or after this bold element
          newStartPath = this.adjustPathForUnwrap(newStartPath, path, vnode.children.length);
          newEndPath = this.adjustPathForUnwrap(newEndPath, path, vnode.children.length);
          
          this.unwrapBold(vdom, path);
        });

        return {
          startPath: newStartPath,
          startOffset: startOffset,
          endPath: newEndPath,
          endOffset: endOffset
        };
      }

      /**
       * Adjusts a path after unwrapping a bold element
       */
      adjustPathForUnwrap(selPath, boldPath, numChildren) {
        // Check if selection path goes through this bold element
        if (selPath.length <= boldPath.length) return selPath;

        // Check if the path matches up to the bold element
        for (let i = 0; i < boldPath.length; i++) {
          if (selPath[i] !== boldPath[i]) {
            // Check if selection is after the bold element at this level
            if (i === boldPath.length - 1 && selPath[i] > boldPath[i]) {
              // Selection is after the bold, needs to shift by (numChildren - 1)
              const newPath = [...selPath];
              newPath[i] = selPath[i] + (numChildren - 1);
              return newPath;
            }
            return selPath;
          }
        }

        // Selection path goes through the bold element
        // Remove the bold element from the path (the child moves up one level)
        const newPath = [...selPath];
        // The index within the bold element becomes the index in the parent
        const indexInBold = selPath[boldPath.length];
        newPath.splice(boldPath.length, 1);
        newPath[boldPath.length - 1] = boldPath[boldPath.length - 1] + indexInBold;
        
        return newPath;
      }

      /**
       * Unwraps a bold element, replacing it with its children
       */
      unwrapBold(vdom, path) {
        if (path.length === 0) return;

        const parentPath = path.slice(0, -1);
        const index = path[path.length - 1];

        let parent = vdom;
        for (const idx of parentPath) {
          parent = parent.children[idx];
        }

        if (!parent || !parent.children[index]) return;

        const boldNode = parent.children[index];
        if (boldNode.type !== 'strong' && boldNode.type !== 'b') return;

        // Replace the bold node with its children
        parent.children.splice(index, 1, ...boldNode.children);
      }

      /**
       * Normalizes the virtual DOM by merging adjacent text nodes
       */
      normalizeVDOM(vnode) {
        if (!vnode.children || vnode.children.length === 0) return;

        // First, normalize all children recursively
        vnode.children.forEach(child => this.normalizeVDOM(child));

        // Then merge adjacent text nodes
        const newChildren = [];
        for (const child of vnode.children) {
          if (child.type === 'TEXT' && child.text === '') {
            continue; // Skip empty text nodes
          }

          const last = newChildren[newChildren.length - 1];
          if (last && last.type === 'TEXT' && child.type === 'TEXT') {
            last.text += child.text;
          } else {
            newChildren.push(child);
          }
        }
        vnode.children = newChildren;

        // Remove empty bold elements
        vnode.children = vnode.children.filter(child => {
          if ((child.type === 'strong' || child.type === 'b') && child.children.length === 0) {
            return false;
          }
          return true;
        });
      }

      /**
       * Updates the bold button active state
       */
      updateBoldButtonState() {
        if (this.isSelectionBold()) {
          this.boldButton.classList.add('active');
        } else {
          this.boldButton.classList.remove('active');
        }
      }

      /**
       * Updates the debug panel
       */
      updateDebug() {
        const debugContent = document.getElementById('debugContent');
        const selectionInfo = document.getElementById('selectionInfo');

        // Format VDOM for display
        const formatVNode = (vnode, indent = 0) => {
          const spaces = '  '.repeat(indent);
          if (vnode.type === 'TEXT') {
            return `${spaces}TEXT: "${vnode.text}"`;
          }
          const props = Object.keys(vnode.props).length > 0 
            ? ` ${JSON.stringify(vnode.props)}` 
            : '';
          const childrenStr = vnode.children
            .map(child => formatVNode(child, indent + 1))
            .join('\n');
          return `${spaces}<${vnode.type}${props}>\n${childrenStr}\n${spaces}</${vnode.type}>`;
        };

        debugContent.textContent = formatVNode(this.vdom);

        // Update selection info
        selectionInfo.textContent = `Selection: ${this.selection.isCollapsed ? 'Collapsed' : 'Range'} | ` +
          `Anchor: [${this.selection.anchorPath.join(',')}]:${this.selection.anchorOffset} | ` +
          `Focus: [${this.selection.focusPath.join(',')}]:${this.selection.focusOffset} | ` +
          `Bold: ${this.isSelectionBold() ? 'Yes' : 'No'}`;
      }
    }

    // ============================================
    // INITIALIZE EDITOR
    // ============================================

    document.addEventListener('DOMContentLoaded', () => {
      const editorElement = document.getElementById('editor');
      window.editor = new VirtualRichTextEditor(editorElement);
    });
  </script>
</body>
</html>
